// Ïï±Ïùò Î©îÏù∏ ÌéòÏù¥ÏßÄ
import React, { useState, useEffect, useCallback, useRef } from 'react';
import Calendar from '../components/Calendar/Calendar';
import CalendarHeader from '../components/Calendar/CalendarHeader';
import Modals from '../components/Modals/Modals';
import CalendarControls from '../components/Calendar/CalendarControls';

// Ïª§Ïä§ÌÖÄ ÌõÖÎì§
import { useScheduleManagement } from '../hooks/useScheduleManagement';
import { useImageProcessing } from '../hooks/useImageProcessing';
import { useVoiceRecording } from '../hooks/useVoiceRecording';
import { useMessageManagement } from '../hooks/useMessageManagement';
import { useLifestyleSync } from '../hooks/useLifestyleSync';
import { usePersonalizedAI } from '../hooks/usePersonalizedAI';
import { useScheduleData } from '../hooks/useScheduleData';
import { useLifestyleManagement } from '../hooks/useLifestyleManagement';
import { useTaskManagement } from '../hooks/useTaskManagement';
import { useFeedbackManagement } from '../hooks/useFeedbackManagement';
import { useAuth } from '../contexts/AuthContext';

// ÏÑúÎπÑÏä§ & Ïú†Ìã∏Î¶¨Ìã∞
import apiService from '../services/apiService';
import firestoreService from '../services/firestoreService';
import { UI_CONSTANTS } from '../constants/ui';
import { 
  buildShedAIPrompt,
  buildFeedbackPrompt,
  convertScheduleToEvents
} from '../utils/scheduleUtils';
import { 
  resetToStartOfDay,
  parseDateString,
  convertToRelativeDay
} from '../utils/dateUtils';
import '../styles/calendar.css';
import '../styles/floating.css';

function CalendarPage() {
  const calendarRef = useRef(null);
  const sessionIdRef = useRef(null);
  const today = resetToStartOfDay(new Date());
  
  // Ïù∏Ï¶ù Î∞è Firebase ÌõÖ
  const { user } = useAuth();
  const { userInsights, generatePersonalizedSchedule } = usePersonalizedAI();
  
  // ÏÉàÎ°úÏö¥ Î∂ÑÎ¶¨Îêú ÌõÖÎì§
  const { 
    allEvents, 
    setAllEvents, 
    loading, 
    lastSchedule, 
    setLastSchedule,
    loadUserData,
    updateSchedule 
  } = useScheduleData();
  const { 
    lifestyleList, 
    setLifestyleList, 
    lifestyleInput, 
    setLifestyleInput,
    isClearing,
    handleAddLifestyle,
    handleDeleteLifestyle,
    handleClearAllLifestyles,
    handleSaveAndGenerateSchedule
  } = useLifestyleManagement();
  const { taskForm, setTaskForm, handleTaskFormSubmit } = useTaskManagement();
  const { feedbackInput, setFeedbackInput, handleSubmitFeedbackMessage } = useFeedbackManagement();

  // sessionIdRef ÏÑ§Ï†ï
  useEffect(() => {
    if (user?.uid) {
      sessionIdRef.current = user.uid;
    }
  }, [user?.uid]);
  
  // Ïª§Ïä§ÌÖÄ ÌõÖÎì§
  const { 
    isLoading, 
    setIsLoading, 
    loadingProgress, 
    generateSchedule 
  } = useScheduleManagement(setAllEvents);
  const { isConverting, convertImageToText } = useImageProcessing();
  const { isRecording, startVoiceRecording } = useVoiceRecording();
  const { 
    messages, 
    conversationContext, 
    attachments, 
    setAttachments, 
    currentMessage, 
    setCurrentMessage, 
    addAIMessage, 
    addUserMessage, 
    removeAttachment, 
    clearMessages 
  } = useMessageManagement();
  
  // UI ÏÉÅÌÉú Í¥ÄÎ¶¨
  const [showTaskModal, setShowTaskModal] = useState(false);
  const [showLifestyleModal, setShowLifestyleModal] = useState(false);
  const [currentScheduleSessionId, setCurrentScheduleSessionId] = useState(null);
  const [chatbotMode, setChatbotMode] = useState(UI_CONSTANTS.CHATBOT_MODES.TASK);
  const [taskInputMode, setTaskInputMode] = useState(UI_CONSTANTS.TASK_INPUT_MODES.CHATBOT);

  // Ïä§ÏºÄÏ§Ñ ÏÉùÏÑ± ÏΩúÎ∞±
  const handleScheduleGeneration = useCallback(async (prompt, message) => {
    addAIMessage(message);
    
    try {
      const result = await generateSchedule(
        prompt,
        {
          conversationContext: conversationContext.slice(-12),
          lifestylePatterns: lifestyleList
        },
        today
      );
      
      setLastSchedule(result.schedule);
      
      if (result.scheduleSessionId) {
        setCurrentScheduleSessionId(result.scheduleSessionId);
      }
      
      // Ïù¥Î≤§Ìä∏Îäî Calendar Ïª¥Ìè¨ÎÑåÌä∏ÏóêÏÑú ÏûêÎèôÏúºÎ°ú Ï≤òÎ¶¨Îê®
      addAIMessage("Ïä§ÏºÄÏ§ÑÏù¥ ÏÉùÏÑ±ÎêòÏóàÏäµÎãàÎã§!");
      
      // Ïä§ÏºÄÏ§Ñ ÏÉùÏÑ± ÏôÑÎ£å ÌõÑ Î™®Îã¨ Îã´Í∏∞
      setShowLifestyleModal(false);
    } catch (error) {
      console.error('Ïä§ÏºÄÏ§Ñ ÏÉùÏÑ± Ïã§Ìå®:', error);
      addAIMessage("Ïä§ÏºÄÏ§Ñ ÏÉùÏÑ±Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§. Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.");
    }
  }, [generateSchedule, conversationContext, lifestyleList, today, addAIMessage]);

  // ÏÉùÌôúÌå®ÌÑ¥ ÎèôÍ∏∞Ìôî
  useLifestyleSync(
    lifestyleList, 
    lastSchedule, 
    today, 
    user?.uid, 
    handleScheduleGeneration,
    { autoGenerate: false, autoSync: false }
  );


  // ÏÉàÎ°úÏö¥ Ï†ÄÏû• + Ïä§ÏºÄÏ§Ñ ÏÉùÏÑ± Ìï®Ïàò
  const handleSaveAndGenerate = useCallback(async () => {
    if (lifestyleList.length === 0) {
      alert('Ï†ÄÏû•Ìï† ÏÉùÌôúÌå®ÌÑ¥Ïù¥ ÏóÜÏäµÎãàÎã§.');
      return;
    }
    
    // Ïä§ÌîºÎÑà ÏãúÏûë
    setIsLoading(true);
    
    try {
      // 1. ÏÉùÌôúÌå®ÌÑ¥ Ï†ÄÏû•
      await handleSaveAndGenerateSchedule();
      
      // 2. Ïä§ÏºÄÏ§Ñ ÏÉùÏÑ±
      const lifestyleText = lifestyleList.join("\n");
      const prompt = lastSchedule 
        ? buildFeedbackPrompt(lifestyleText, "", lastSchedule)
        : buildShedAIPrompt(lifestyleText, "", today);
      
      await handleScheduleGeneration(prompt, "ÏÉùÌôúÌå®ÌÑ¥ÏùÑ Ï†ÄÏû•ÌïòÍ≥† Ïä§ÏºÄÏ§ÑÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§...");
      
    } catch (error) {
      console.error('Ï†ÄÏû• Î∞è Ïä§ÏºÄÏ§Ñ ÏÉùÏÑ± Ïã§Ìå®:', error);
      alert('Ï†ÄÏû• Î∞è Ïä§ÏºÄÏ§Ñ ÏÉùÏÑ±Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§: ' + error.message);
    } finally {
      // Ïä§ÌîºÎÑà Ï¢ÖÎ£å
      setIsLoading(false);
    }
  }, [lifestyleList, lastSchedule, today, handleScheduleGeneration, handleSaveAndGenerateSchedule, setIsLoading]);

  // Ìèº ÏûÖÎ†•Í∞í Î≥ÄÍ≤Ω Ìï∏Îì§Îü¨
  const handleTaskFormChange = (e) => {
    const { id, value } = e.target;
    setTaskForm({
      ...taskForm,
      [id.replace('task-', '')]: value
    });
  };

  // Ï§ëÏöîÎèÑ, ÎÇúÏù¥ÎèÑ Î≤ÑÌäº ÏÑ†ÌÉù Ìï∏Îì§Îü¨
  const handleLevelSelect = (field, value) => {
    setTaskForm({
      ...taskForm,
      [field]: value
    });
  };

  // Ìï† Ïùº Ï†úÏ∂ú Ìï∏Îì§Îü¨ (ÏÉàÎ°úÏö¥ ÌõÖ ÏÇ¨Ïö©)
  const handleTaskSubmit = () => {
    handleTaskFormSubmit((formattedMessage) => {
      addUserMessage(formattedMessage, []);
      handleProcessMessageWithAI(formattedMessage);
      setShowTaskModal(false);
    });
  };

  // Î©îÏãúÏßÄ Ï†úÏ∂ú Ìï∏Îì§Îü¨
  const handleSubmitMessage = () => {
    if (currentMessage.trim() === "" && attachments.length === 0) return;
    if (isLoading) return;

    addUserMessage(currentMessage, [...attachments]);
    setAttachments([]);
    
    if (chatbotMode === "feedback") {
      handleFeedbackSubmit();
    } else {
      handleProcessMessageWithAI(currentMessage);
    }
    
    setCurrentMessage("");
  };

  // ÌîºÎìúÎ∞± Ï†úÏ∂ú Ìï∏Îì§Îü¨ (ÏÉàÎ°úÏö¥ ÌõÖ ÏÇ¨Ïö©)
  const handleFeedbackSubmit = () => {
    handleSubmitFeedbackMessage(currentMessage, (messageText, analysis, advice) => {
      if (analysis) {
        addAIMessage(`üìä ÌîºÎìúÎ∞± Î∂ÑÏÑù: ${analysis}`);
      }
      
      if (advice && advice.length > 0) {
        const adviceText = advice.map(item => 
          `üí° ${item.title || 'Ï°∞Ïñ∏'}: ${item.content}`
        ).join('\n');
        addAIMessage(adviceText);
      }
      
      addAIMessage("ÌîºÎìúÎ∞±ÏùÑ Î∞òÏòÅÌïòÏó¨ Ïä§ÏºÄÏ§ÑÏùÑ Ï°∞Ï†ïÌï©ÎãàÎã§...");
      
      const lifestyleText = lifestyleList.join("\n");
      const feedbackPrompt = buildFeedbackPrompt(lifestyleText, messageText, lastSchedule);
      handleScheduleGeneration(feedbackPrompt, "ÌîºÎìúÎ∞±ÏùÑ Î∞òÏòÅÌïòÏó¨ Ïä§ÏºÄÏ§ÑÏùÑ Ï°∞Ï†ïÌï©ÎãàÎã§...");
    });
  };
  
  // Î©îÏãúÏßÄÎ•º AIÎ°ú Ï≤òÎ¶¨ÌïòÎäî Ìï®Ïàò
  const handleProcessMessageWithAI = async (messageText) => {
    const preprocessMessage = (text) => {
      const patterns = [
        /Ïù¥Î≤à\s*Ï£º\s*(Ïõî|Ìôî|Ïàò|Î™©|Í∏à|ÌÜ†|Ïùº)ÏöîÏùº/g,
        /Îã§Ïùå\s*Ï£º\s*(Ïõî|Ìôî|Ïàò|Î™©|Í∏à|ÌÜ†|Ïùº)ÏöîÏùº/g,
        /(\d{1,2})Ïõî\s*(\d{1,2})Ïùº/g,
        /(\d+)Ïùº\s*(ÌõÑ|Îí§)/g,
        /(\d+)Ï£º\s*(ÌõÑ|Îí§)/g,
        /Îã§Ïùå\s*(Ïõî|Ìôî|Ïàò|Î™©|Í∏à|ÌÜ†|Ïùº)ÏöîÏùº/g,
        /Ïò§Îäî\s*(Ïõî|Ìôî|Ïàò|Î™©|Í∏à|ÌÜ†|Ïùº)ÏöîÏùº/g,
        /Ïù¥Î≤à\s*(Ïõî|Ìôî|Ïàò|Î™©|Í∏à|ÌÜ†|Ïùº)ÏöîÏùº/g,
        /(\d{4})ÎÖÑ\s*(\d{1,2})Ïõî\s*(\d{1,2})Ïùº/g
      ];
    
      let processed = text;
    
      for (const pattern of patterns) {
        processed = processed.replaceAll(pattern, (match) => {
          const parsed = parseDateString(match, today);
          if (!parsed) return match;
    
          const day = convertToRelativeDay(parsed, today);
          return `${match} (day:${day})`;
        });
      }
    
      return processed;
    };
    
    const processedMessage = preprocessMessage(messageText);
    
    setIsLoading(true);
    setShowTaskModal(false);
    setShowLifestyleModal(false);
    addAIMessage("Ïä§ÏºÄÏ§ÑÏùÑ ÏÉùÏÑ±ÌïòÎäî Ï§ëÏûÖÎãàÎã§...");
    
    const lifestyleText = lifestyleList.join("\n");
    const prompt = lastSchedule 
      ? buildFeedbackPrompt(lifestyleText, processedMessage, lastSchedule)
      : buildShedAIPrompt(lifestyleText, processedMessage, today);

    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 60000);
      
      const newSchedule = await apiService.generateSchedule(
        prompt,
        {
          conversationContext: conversationContext.slice(-12),
          lifestylePatterns: lifestyleList
        },
        sessionIdRef.current
      );
      
      clearTimeout(timeoutId);


      setLastSchedule(newSchedule.schedule);

      // FirebaseÏóê Ïä§ÏºÄÏ§Ñ Ï†ÄÏû•
      try {
        const saveData = {
          scheduleData: newSchedule.schedule,
          hasSchedule: true,
          lifestyleContext: lifestyleList.join('\n'),
          taskContext: prompt,
          conversationContext: conversationContext.slice(-12)
        };
        
        
        const scheduleSessionId = await firestoreService.saveScheduleSession(user.uid, saveData);
        
        setCurrentScheduleSessionId(scheduleSessionId);
      } catch (error) {
        console.error('[Calendar] Firebase Ï†ÄÏû• Ïã§Ìå®:', error);
      }

      const events = convertScheduleToEvents(newSchedule.schedule, today).map(event => ({
        ...event,
        extendedProps: {
          ...event.extendedProps,
          isDone: false,
        }
      }));


      setAllEvents(events);
      // Ïù¥Î≤§Ìä∏Îäî Calendar Ïª¥Ìè¨ÎÑåÌä∏ÏóêÏÑú ÏûêÎèôÏúºÎ°ú Ï≤òÎ¶¨Îê®

      const calendarApi = calendarRef.current?.getApi();
      if (calendarApi) {
        const currentView = calendarApi.view.type;
        calendarApi.changeView(currentView);
      }

      const aiResponse = typeof newSchedule.notes === "string"
        ? newSchedule.notes.replace(/\n/g, "<br>")
        : (newSchedule.notes || []).join("<br>");
      
      addAIMessage("Ïä§ÏºÄÏ§ÑÏùÑ ÏÉùÏÑ±ÌñàÏäµÎãàÎã§!");
      addAIMessage(aiResponse);
    } catch (e) {
      console.error('Ïä§ÏºÄÏ§Ñ ÏÉùÏÑ± ÏöîÏ≤≠ Ïã§Ìå®:', e);
      addAIMessage("ÏöîÏ≤≠ Ïã§Ìå®: Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.");
    } finally {
      setIsLoading(false);
    }
  };

  // Ï∫òÎ¶∞Îçî Ï¥àÍ∏∞Ìôî Ìï®Ïàò
  const handleResetCalendar = async () => {
    if (!user?.uid) return;
    if (window.confirm("Î™®Îì† ÏùºÏ†ïÏùÑ Ï¥àÍ∏∞ÌôîÌïòÏãúÍ≤†ÏäµÎãàÍπå?")) {
      try {
        // FirestoreÏóêÏÑú ÏµúÏã† Ïä§ÏºÄÏ§Ñ ÎπÑÌôúÏÑ±Ìôî/ÏÇ≠Ï†ú Ï≤òÎ¶¨
        await firestoreService.deleteLatestSchedule(user.uid);
        // Î°úÏª¨ Î∞±ÏóÖ Ï†úÍ±∞
        try { localStorage.removeItem('shedAI:lastSchedule'); } catch {}
      } catch (e) {
        console.error('Ïä§ÏºÄÏ§Ñ ÏÇ≠Ï†ú Ï≤òÎ¶¨ Ïã§Ìå®:', e);
      }

      setLastSchedule(null);
      setAllEvents([]);
      calendarRef.current?.getApi().removeAllEvents();
      clearMessages();
      setCurrentScheduleSessionId(null);
      addAIMessage("Ï∫òÎ¶∞ÎçîÍ∞Ä Ï¥àÍ∏∞ÌôîÎêòÏóàÏäµÎãàÎã§. ÏÉàÎ°úÏö¥ ÏùºÏ†ïÏùÑ Ï∂îÍ∞ÄÌï¥Ï£ºÏÑ∏Ïöî.");
    }
  };

  // AI Ï°∞Ïñ∏ Ï°∞Ìöå
  const fetchAIAdvice = async () => {
    try {
      const result = await apiService.getAdvice(sessionIdRef.current);
      
      if (result.advice && result.advice.length > 0) {
        const adviceText = result.advice.map(item => 
          `üí° ${item.title || 'Ï°∞Ïñ∏'}: ${item.content}`
        ).join('\n');
        addAIMessage(adviceText);
      } else {
        addAIMessage("ÌòÑÏû¨ Ï†úÍ≥µÌï† AI Ï°∞Ïñ∏Ïù¥ ÏóÜÏäµÎãàÎã§.");
      }
    } catch (error) {
      console.error("AI Ï°∞Ïñ∏ Ï°∞Ìöå Ïã§Ìå®:", error);
      addAIMessage("AI Ï°∞Ïñ∏ÏùÑ Î∂àÎü¨Ïò§ÎäîÎç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§.");
    }
  };

  // Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú Ìï∏Îì§Îü¨
  const handleImageUpload = async (event) => {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
      const newAttachment = {
        type: 'image',
        data: e.target.result,
        file: file
      };
      setAttachments(prev => [...prev, newAttachment]);
    };
    reader.readAsDataURL(file);

    try {
      const text = await convertImageToText(file);
      if (text) {
        setCurrentMessage(text);
      }
    } catch (error) {
      console.error('Ïù¥ÎØ∏ÏßÄ OCR Ïã§Ìå®:', error);
    }

    event.target.value = null;
  };

  // ÏùåÏÑ± ÎÖπÏùå Ìï∏Îì§Îü¨
  const handleVoiceRecording = async () => {
    try {
      const text = await startVoiceRecording();
      setCurrentMessage(text);
    } catch (error) {
      console.error('ÏùåÏÑ± ÎÖπÏùå Ïã§Ìå®:', error);
    }
  };

  // ÏÉùÌôúÌå®ÌÑ¥ Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú (OCR Í≤∞Í≥ºÎ•º ÏÉùÌôúÌå®ÌÑ¥ ÏûÖÎ†•Ï∞ΩÏóê Î∞òÏòÅ)
  const handleLifestyleImageUpload = async (event) => {
    const file = event.target.files?.[0];
    if (!file) return;

    try {
      const text = await convertImageToText(file);
      if (text) {
        setLifestyleInput(prev => (prev ? prev + "\n" : "") + text);
      }
    } catch (error) {
      console.error('ÏÉùÌôúÌå®ÌÑ¥ Ïù¥ÎØ∏ÏßÄ OCR Ïã§Ìå®:', error);
    }

    event.target.value = null;
  };

  // ÏÉùÌôúÌå®ÌÑ¥ ÏùåÏÑ± ÏûÖÎ†• (Ïù∏Ïãù ÌÖçÏä§Ìä∏Î•º ÏÉùÌôúÌå®ÌÑ¥ ÏûÖÎ†•Ï∞ΩÏóê Î∞òÏòÅ)
  const handleLifestyleVoiceRecording = async () => {
    try {
      const text = await startVoiceRecording();
      if (text) {
        setLifestyleInput(prev => (prev ? prev + "\n" : "") + text);
      }
    } catch (error) {
      console.error('ÏÉùÌôúÌå®ÌÑ¥ ÏùåÏÑ± ÎÖπÏùå Ïã§Ìå®:', error);
    }
  };

  // Ï∫òÎ¶∞Îçî Ïù¥Î≤§Ìä∏ Ìï∏Îì§Îü¨Îì§
  const handleEventMount = (info) => {
    if (info.event.extendedProps?.type === "lifestyle") {
      const viewType = calendarRef.current?.getApi().view.type;
      
      if (viewType === "dayGridMonth") {
        // ÏõîÍ∞Ñ Î∑∞ÏóêÏÑú lifestyle Ïù¥Î≤§Ìä∏ Ïà®ÍπÄ
        info.el.style.display = "none";
      } else {
        // Ï£ºÍ∞Ñ/ÏùºÍ∞Ñ Î∑∞ÏóêÏÑú lifestyle Ïù¥Î≤§Ìä∏ Ïä§ÌÉÄÏùºÎßÅ
        info.el.style.backgroundColor = "#CFCFCF";
        info.el.style.borderColor = "#AAAAAA";
        info.el.style.color = "#333333";
        info.el.style.fontWeight = "normal";
      }
    }
  };

  const handleViewDidMount = (arg) => {
    // Ïù¥Î≤§Ìä∏Îäî Calendar Ïª¥Ìè¨ÎÑåÌä∏ÏóêÏÑú ÏûêÎèôÏúºÎ°ú Ï≤òÎ¶¨Îê®
  };

  const handleDatesSet = (arg) => {
    // Ïù¥Î≤§Ìä∏Îäî Calendar Ïª¥Ìè¨ÎÑåÌä∏ÏóêÏÑú ÏûêÎèôÏúºÎ°ú Ï≤òÎ¶¨Îê®
  };

  const handleDayHeaderContent = (args) => {
    const weekday = args.date.toLocaleDateString("en-US", { weekday: "short" });
    const span = document.createElement("span");
    span.textContent = weekday;
    return { domNodes: [span] };
  };

  const handleEventContent = (arg) => {
    const viewType = calendarRef.current?.getApi().view.type;
    const { isDone } = arg.event.extendedProps || {};
    const titleText = arg.event.title;

    const span = document.createElement("span");
    span.textContent = titleText;
    span.title = titleText;
    if (isDone) span.style.textDecoration = "line-through";

    if (viewType === "dayGridMonth") {
      return { domNodes: [span] };
    }

    if (viewType !== "dayGridMonth" && arg.event.extendedProps?.type === "task") {
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.checked = isDone ?? false;
      checkbox.style.marginRight = "5px";
      checkbox.addEventListener("change", () => {
        arg.event.setExtendedProp("isDone", checkbox.checked);    
        setAllEvents(prevEvents => {
          return prevEvents.map(event => {
            if (event.title === arg.event.title && 
                new Date(event.start).getTime() === new Date(arg.event.start).getTime() &&
                new Date(event.end).getTime() === new Date(arg.event.end).getTime()) {
              return {
                ...event,
                extendedProps: {
                  ...event.extendedProps,
                  isDone: checkbox.checked
                }
              };
            }
            return event;
          });
        });
      });

      const container = document.createElement("div");
      container.appendChild(checkbox);
      container.appendChild(span);
      return { domNodes: [container] };
    }
    
    return {domNodes:[span]}
  };

  return (
    <div className="calendar-page">
      <CalendarHeader isLoading={isLoading} loadingProgress={loadingProgress} />
      
      <Calendar
        ref={calendarRef}
        events={allEvents}
        onEventMount={handleEventMount}
        onViewDidMount={handleViewDidMount}
        onDatesSet={handleDatesSet}
        onDayHeaderContent={handleDayHeaderContent}
        onEventContent={handleEventContent}
      />

      <CalendarControls
        onPlusClick={() => {
          // Îã§Î•∏ Î™®Îã¨Ïù¥ Ïó¥Î†§ÏûàÏúºÎ©¥ Î®ºÏ†Ä Îã´Í∏∞
          setShowLifestyleModal(false);
          setTaskInputMode(UI_CONSTANTS.TASK_INPUT_MODES.CHATBOT);
          setShowTaskModal(true);
        }}
        onPencilClick={() => {
          // Îã§Î•∏ Î™®Îã¨Ïù¥ Ïó¥Î†§ÏûàÏúºÎ©¥ Î®ºÏ†Ä Îã´Í∏∞
          setShowTaskModal(false);
          setShowLifestyleModal(true);
        }}
        onAdviceClick={fetchAIAdvice}
        onReportClick={() => window.location.href = '/report'}
        onResetClick={handleResetCalendar}
      />

      <Modals
        // Task Modal Props
        showTaskModal={showTaskModal}
        setShowTaskModal={setShowTaskModal}
        taskInputMode={taskInputMode}
        setTaskInputMode={setTaskInputMode}
        messages={messages}
        currentMessage={currentMessage}
        setCurrentMessage={setCurrentMessage}
        attachments={attachments}
        onRemoveAttachment={removeAttachment}
        onSubmitMessage={handleSubmitMessage}
        onImageUpload={handleImageUpload}
        onVoiceRecording={handleVoiceRecording}
        isRecording={isRecording}
        isConverting={isConverting}
        isLoading={isLoading}
        chatbotMode={chatbotMode}
        onModeChange={setChatbotMode}
        
        // Task Form Props
        taskForm={taskForm}
        onTaskFormChange={handleTaskFormChange}
        onLevelSelect={handleLevelSelect}
        onTaskFormSubmit={handleTaskSubmit}
        
        // Lifestyle Modal Props
        showLifestyleModal={showLifestyleModal}
        setShowLifestyleModal={setShowLifestyleModal}
        lifestyleList={lifestyleList}
        lifestyleInput={lifestyleInput}
        setLifestyleInput={setLifestyleInput}
        isClearing={isClearing}
        onAddLifestyle={handleAddLifestyle}
        onDeleteLifestyle={handleDeleteLifestyle}
        onClearAllLifestyles={handleClearAllLifestyles}
        onLifestyleImageUpload={handleLifestyleImageUpload}
        onLifestyleVoiceRecording={handleLifestyleVoiceRecording}
        onSaveLifestyleAndRegenerate={handleSaveAndGenerate}
      />
    </div>
  );
}

export default CalendarPage;